function getIdFromHandle(str){	var arr = str.split('_');	var tmpStr = "";	for (i=1;i<arr.length;i++){		tmpStr = tmpStr + arr[i] + '_';	}	return tmpStr.substr(0,tmpStr.length-1);}var HomeBox = {	columns:      { homeColumnLeft:   {id:1, xStart:0, xEnd:0}, 					homeColumnCenter: {id:2, xStart:0, xEnd:0},					homeColumnRight:  {id:3, xStart:0, xEnd:0} },	dragObj:   null,	rect:      null,	boxes:     null,	lastX:     0,	lastY:     0,	mouseX:    0,	mouseY:    0,	dropPos:   0, // dropped box position	tmp:       0, // various tmp neesd	accessRule: null,	targetObject: null,	targetColumnIndex: null,	columnBoxCount: null,		init: function () {		this.boxes = new Object();		this.createFrame();		this.registerBoxes();	},		setAccessRule: function (access) {		this.accessRule = access;	},		registerBoxes: function () {		var boxes = document.getElementsByTagName("DIV");		var thisDiv = null;		for (b=0; b<boxes.length; b++) {			thisDiv = boxes[b];			isBox = false;			if (thisDiv.id.indexOf("homebox")>-1)				isBox = getIdFromHandle(thisDiv.id);			if (isBox) { 				this.registerBox(thisDiv, isBox); 			}			}			this.dropPos = 0;		this.tmp = 0;	},	// receives a div object and generates a HomeBox out of it	registerBox: function(obj, boxName) { 		var pos = this.findPosition(obj); 		var handleId = 'handle_' + getIdFromHandle(obj.id);		//alert(handleId);		var handle = document.getElementById(handleId);		var thisCol = this.getColumn(obj);		if (handle) handle.rootId = obj.id;		if (thisCol!=this.tmp) {			this.dropPos = 10;			this.tmp = thisCol; 		} else { 			this.dropPos += 10;		}				var box = {			id:       obj.id,			boxName:  boxName, 			handleId: handleId,			handle:   handle,			root:     obj,			width:    obj.offsetWidth,			height:   obj.offsetHeight,			zIndex:   obj.style.zIndex,			column:   thisCol,			position: this.dropPos		}; 		this.setDragHandler(box);		this.boxes[obj.id] = box;	},		getBox: function (id) {		return this.boxes[id];	},			getColumn: function (obj) {		var idName = obj.parentNode.id;		var colNum = this.columns[idName].id; 		if (!isNaN(colNum)) {			return colNum;		} else {			return -1;		}	},	setDragHandler: function(box) {		var root = box.root;		var handle = box.handle;		if (handle != null) {			var zIndex = box.zIndex;			var rootId = box.id;			handle.rootId = rootId;			Drag.init( handle, root ); 			box.root.onDrag      = function(x, y) { HomeBox.boxDrag(rootId, x, y); };			box.root.onDragStart = function(x, y) { HomeBox.boxClick(rootId, x , y); };			box.root.onDragEnd   = function()     { HomeBox.boxDrop(rootId,true); };		}	},	  	createFrame: function() {		//var box = document.getElementById(rootId);		var rect = document.createElement("DIV");		rect.style.position = 'relative';		rect.style.zIndex = 0;		rect.className = 'homeBoxFrame';		rect.style.display = 'none';		rect.id = "homeboxLocator";		document.body.appendChild(rect);		return rect;	},		moveFrame: function (rootId, lastBox) {		var box = document.getElementById(rootId);		var rect = document.getElementById('homeboxLocator');		if (rect==null) rect = this.createFrame();		rect.style.display = 'block';		if (box.parentNode.nodeName == 'DIV') {			if (lastBox) {				box.parentNode.appendChild(rect);			} else {				box.parentNode.insertBefore(rect, box);			}		} else {			box.appendChild(rect);		}		rect.style.height = this.dragObj.offsetHeight + 'px'; 		rect.style.width  = this.dragObj.offsetWidth + 'px'; 	},		removeFrame: function() {		var rect = document.getElementById('homeboxLocator');		if (rect) rect.style.display = 'none'; 	},		setMousePos: function(e) {		HomeBox.mouseX = document.all ? event.clientX + document.body.scrollLeft : e.clientX;		HomeBox.mouseY = document.all ? event.clientY + document.body.scrollTop  : e.clientY;  	},		position: function (obj, x, y) {		obj.style.left = x + 'px';		obj.style.top  = y + 'px';	},		getBoxIndex: function (obj,isLast){		var i = 1;		for (var columnName in this.columns){			if (this.getColumn(obj) == i){										var rows = document.getElementById(columnName);					var k = 0;					for (var j=0;j<rows.childNodes.length;j++){						if (rows.childNodes[j].id){														if (rows.childNodes[j].id == obj.id)								return k;							k++;						}					}				return -1;			}			i++;		}	},		getBoxFromIndex : function (index,column){		var i = 1;		for (var columnName in this.columns){			if (column == i){										var rows = document.getElementById(columnName);					var k = 0;					for (var j=0;j<rows.childNodes.length;j++){							if (rows.childNodes[j].id){							if (k == index)								return rows.childNodes[j];							k++;						}					}				return rows;			}			i++;		}			},		boxClick: function (rootId, x, y) {		this.bindEvent('mousemove', document, HomeBox.setMousePos);		this.setColumnPositions();		var box = document.getElementById(rootId);				this.dragObj = box;		this.moveFrame(rootId);								box.style.zIndex=199;		box.style.width = box.offsetWidth + 'px';		box.style.top = this.mouseY;		box.style.left = this.mouseX;		box.style.textAlign = 'left';		box.style.filter = 'alpha(opacity=70)';		box.style.opacity = '0.7'; 			},		boxDrag: function(rootId, x, y) {   		this.findBoxUnder(rootId, x, y);	},		boxDrop: function (id,accessState) {		this.unbindEvent('mousemove', document, HomeBox.setMousePos);		var homebox = this.boxes[id];		var box = document.getElementById(id);		var rect = document.getElementById('homeboxLocator');			var col = rect.parentNode;		var colNum = this.columns[col.id].id;				if (this.accessRule[id] != null){			for (var i=0;i<this.accessRule[id].length;i++){				if (colNum==this.accessRule[id][i]){					box.style.position = 'fixed';					box.style.filter = null;					box.style.opacity = null;					var index = this.getBoxIndex(box)+1;					var targetId = this.getBoxFromIndex(index,this.getColumn(box)).id;					this.setPositions(box.id,targetId);					return;				}			}		}else{			accessState = true;			}		this.boxes[id].column=colNum;		box.style.zIndex = homebox.zIndex;		box.style.position = 'relative';		box.style.left = '0px';		box.style.top  = '0px'; 		box.style.filter = null;		box.style.opacity = null;		box.style.width = '100%';		col.replaceChild(box, rect ); 				// perform the ondrop event handler passing box name, column and vertical order.				if (accessState)			this.onBoxDrop(homebox.boxName, this.columns[col.id].id, this.dropPos-5);					this.dragObj = null;	},		setColumnPositions: function () {		var col, pos;		var prevCol = false;		for (var c in this.columns) {				col = document.getElementById(c);			pos = this.findPosition(col);			this.columns[c].xStart = pos.x;			if (prevCol && prevCol!=c) this.columns[prevCol].xEnd = pos.x-5;			prevCol = c;		}	},		setPositions: function (rootId,targetId) {		/*		var obj = document.getElementById(name);		var pos = pos = this.findPosition(document.getElementById(column));		obj.style.left = pos.x;		obj.style.top = pos.y;		obj.style.position = 'absolute';		*/		this.dragObj = document.getElementById(rootId);		this.moveFrame(targetId);		this.boxDrop(rootId,false);	},			findColumnUnder: function (xLeft, xRight) {		for (var c in this.columns) {			if (this.mouseX > this.columns[c].xStart && ( this.columns[c].xEnd==0 || this.mouseX < this.columns[c].xEnd)) {				return c;			}		}		return '';	},		findBoxUnder: function (id, x, y) { // gelen id taşınan nesneye aittir			var thisBox, i, b;		var dragBox = this.boxes[id];		var box = document.getElementById(id);		var pos = this.findPosition(box); 		var mW, mH; // median width, median height		var topRight = pos.x+box.offsetWidth;		var bottomLeft = pos.y + box.offsetHeight;		var colName = this.findColumnUnder(pos.x, topRight); // o anda box ın olduğu column name		box.style.position = 'absolute'; //taşınan box absolute yapıldı		this.position(box, this.mouseX - 20, this.mouseY - 10);				if (colName!='') {			var colNum = this.columns[colName].id;						var colBoxes = this.getBoxesFromColumn(colNum); //o columndaki panelleri getirir			this.columnBoxCount = colBoxes.length;			this.targetColumnIndex = colNum;			//document.getElementById('aciklama').innerHTML = this.columnBoxCount + '________'+this.targetColumnIndex;						if (colBoxes.length == 0) {				this.targetObject = colNum;				this.moveFrame(colName);				this.dropPos = 1;				return true;			} else {				for (i=0; i<colBoxes.length; i++) {					b = colBoxes[i];					thisBox = this.boxes[b];  					thisRoot = document.getElementById(b); // sırasıyla taşınacak sutunun panelleri										rangeX1 = this.findPosition(thisRoot).x;					rangeX2 = rangeX1 + thisRoot.offsetWidth;										rangeY1 = this.findPosition(thisRoot).y;															rangeY2 = rangeY1 + thisRoot.offsetHeight;										//document.getElementById('aciklama').innerHTML = pos.x+'>'+rangeX1+'&&'+pos.x+'<'+rangeX2+') && ('+pos.y+'>'+rangeY1+' && '+pos.y+'<'+rangeY2;					if ((pos.x>rangeX1 && pos.x<rangeX2) && ((pos.y>rangeY1 && pos.y<rangeY2))) { 						this.moveFrame(b);						this.dropPos = thisBox.position;						this.targetObject = thisRoot;						//document.getElementById('aciklama').innerHTML = '11111111111---->'+ this.targetObject.id +'_'+ box.id;						return true;					}  										if (i == colBoxes.length-1 && (pos.y>rangeY2)) {						this.moveFrame(b, true);						this.dropPos = thisBox.position + 20;						this.targetObject = thisRoot;						//document.getElementById('aciklama').innerHTML = '2222222222---->'+ this.targetObject.id +'_'+ box.id;						return true;					}				}			}		}  		return false;	}, 		getBoxesFromColumn: function (colNum) {		var boxes = new Array(0);		for (var b in this.boxes) {			if (this.boxes[b].column==colNum) {				boxes.push(b); 			}		}		return boxes;	},		findPosition: function (obj) {		var lft = 0;		var top = 0;								if (obj.offsetParent) {			lft = obj.offsetLeft			top = obj.offsetTop			while (obj = obj.offsetParent) {				lft += obj.offsetLeft				top += obj.offsetTop			}		}						//lft = AutoComplete_GetLeft(obj);		//top = AutoComplete_GetTop(obj);				return {x:lft,y:top};	}, 					removeControlPanel: function() {		var p = document.getElementById('homeBoxCtrlPanel');		if (p!=null && p!='undefined') {			p.parentNode.removeChild(p);		}	},		boxDataFromCtrl: function (e) {		if (!e) e = window.event;		var boxId = e.target ? e.target.boxId : e.srcElement.boxId;		var homebox = HomeBox.boxes[boxId];		var box = document.getElementById(boxId);		var col = document.getElementById(boxId).parentNode;		var colNum = HomeBox.columns[col.id].id;		return  {					boxId: boxId,					homebox: homebox,					box: box,					col: col,					colNum: colNum				};	},		moveBox: function (name, col, pos ){		if (col!=null) {			this.onBoxMove(name, col, pos);		}	},		// handles rpc calls. This is not really used here but you can use it in your 	// event handles should you need it. 	request: function (url, callBack) {		if (window.ActiveXObject) { // The M$ 'standard'			try {				this.req = new ActiveXObject("Msxml2.XMLHTTP");			} catch(e) {				this.req = new ActiveXObject("Microsoft.XMLHTTP");			}			if (this.req) { 				this.req.onreadystatechange =   callBack;				this.req.open("GET", url, true);				this.req.send();			}		} else if (window.XMLHttpRequest) { // native XMLHttpRequest			this.req = new XMLHttpRequest();			this.req.onreadystatechange =  callBack; 			this.req.open("GET", url, true);			this.req.send(null);		} 	}, 	  	bindEvent: function (evt, obj, act) {		if (obj.addEventListener) {			obj.addEventListener(evt, act, false);		} else if (obj.attachEvent) {			obj.attachEvent('on'+evt, act);		}	},		unbindEvent: function (evt, obj, act) {		if (obj.removeEventListener) {			obj.removeEventListener(evt, act, false);		} else if (obj.detachEvent) {			obj.detachEvent('on'+evt, act);		}	},		// Returns the dimensions of an element on screen. Lifted from the wonderful     // prototype framework    getDimensions: function(obj) {        //var display = obj.getStyle('display');        //if (display != 'none' && display != null) // Safari bug        //  return {width: element.offsetWidth, height: element.offsetHeight};        // All *Width and *Height properties give 0 on elements with display none,        // so enable the element temporarily        var objStyle = obj.style;        var originalVisibility = objStyle.visibility;        var originalPosition = objStyle.position;        var originalDisplay = objStyle.display;        objStyle.visibility = 'hidden';        objStyle.position = 'absolute';        objStyle.display = 'block';        var originalWidth = obj.clientWidth;        var originalHeight = obj.clientHeight;        objStyle.display = originalDisplay;        objStyle.position = originalPosition;        objStyle.visibility = originalVisibility;        return {width: originalWidth, height: originalHeight};    },        removeBox: function (boxid) {		this.onBoxRemove(boxid);    },		onBoxRemove: function (boxid) {		var obj = document.getElementById('homebox_'+name);		panelName = '&panelName=homebox_'+name;		//alert('index.cfm?fuseaction=myhome.emptypopup_menu_positions&islem=delete'+panelName);		return;		AjaxPageLoad('index.cfm?fuseaction=myhome.emptypopup_menu_positions&islem=delete'+panelName,'sonuc',1);	},		onBoxMove: function (name, col, pos) {	},	 	debug: function (str) {	}}